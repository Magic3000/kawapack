using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;
using UnityEngine.Rendering;

namespace Kawashirov.FLT  
{
	[CreateAssetMenu(menuName = "Kawashirov Flat Lit Toon Shader Generator")]
	public class Generator : ScriptableObject {
		private static readonly string NAME_PATTERN = @"[a-zA-Z0-9_-]+";

		public string shaderName = "";
		public ShaderComplexity complexity = ShaderComplexity.VF;
		public BlendTemplate mode = BlendTemplate.Opaque;
		public CullMode cull = CullMode.Back;
		public bool instancing = true;
		public int queueOffset = 0;
		public bool disableBatching = false;
		public bool forceNoShadowCasting = false;
		public bool ignoreProjector = true;
		public bool zWrite = true;
		public bool debug = false;

		public MainTexKeywords mainTex = MainTexKeywords.ColorMask;
		public CutoutMode cutout = CutoutMode.Classic;
		public EmissionMode emission = EmissionMode.Custom;
		public bool bumpMap = false;

		public ShadingMode shading = ShadingMode.KawashirovFLTSingle;

		public DistanceFadeMode distanceFade = DistanceFadeMode.None;
		public bool distanceFadeBackward = false;
		public DistanceFadeRandom distanceFadeRandom = DistanceFadeRandom.PerPixel;

		public FPSMode FPS = FPSMode.None;

		public OutlineMode outline = OutlineMode.None;

		public bool infinityWarDecimation = false;

		public PolyColorWaveMode polyColorWave = PolyColorWaveMode.None;

		public Shader result = null;


		public void Generate()
		{
			var assets = AssetDatabase.FindAssets("KawaFLT.shader");
			if (assets.Length != 1) {
				EditorUtility.DisplayDialog(
					"Asset not found",
					"Can not find KawaFLT.shader.txt: \n" + string.Join(",\n", assets),
					"OK"
				);
				return;
			}
			var shader_template_guid = assets[0];
			var shader_template_path = AssetDatabase.GUIDToAssetPath(shader_template_guid);
			//EditorUtility.DisplayDialog("shader_template_path", shader_template_path, "OK");
			var shader_template = AssetDatabase.LoadAssetAtPath(shader_template_path, typeof(TextAsset)) as TextAsset;
			// EditorUtility.DisplayDialog("TextAsset", shader_template.text, "OK");
			var shader_cginc_path = System.IO.Path.GetDirectoryName(shader_template_path);
			//EditorUtility.DisplayDialog("shader_cginc_path", shader_cginc_path, "OK");

			var shader = new ShaderSetup {
				name = this.shaderName.Trim()
			};

			if (string.IsNullOrEmpty(shader.name)) {
				EditorUtility.DisplayDialog("Invalid Shader Name", "Shader Name is Empty!", "OK");
				return;
			}
			if (!Regex.Match(shader.name, NAME_PATTERN).Success) {
				EditorUtility.DisplayDialog("Invalid Shader Name", "Shader Name should match " + NAME_PATTERN, "OK");
				return;
			}
			this.ConfigureGeneral(ref shader);
			this.ConfigureBlending(ref shader);
			this.ConfigureFeatureMainTex(ref shader);
			this.ConfigureFeatureCutoff(ref shader);
			this.ConfigureFeatureEmission(ref shader);
			this.ConfigureFeatureNormalMap(ref shader);

			this.ConfigureFeatureShading(ref shader);

			this.ConfigureFeatureDistanceFade(ref shader);
			this.ConfigureFeatureFPS(ref shader);

			var code = new StringBuilder(1024 * 12);
			code.Append("// DO NOT EDIT THIS FILE\n");
			code.Append("// It's genarated by scripts and used by scripts.\n");
			code.Append("// НЕ ИЗМЕНЯЙТЕ ЭТОТ ФАЙЛ\n");
			code.Append("// Он сгенерирован скриптами и используется скриптами.\n");
			shader.Bake(ref code);

			var shader_generated_path = string.Format("{0}/_generated_{1}.shader", shader_cginc_path, this.shaderName);
			using (var writer = new StreamWriter(shader_generated_path)) {
				writer.Write(code.ToString());
				writer.Flush();
			}
			AssetDatabase.ImportAsset(shader_generated_path);
			this.result = AssetDatabase.LoadAssetAtPath<Shader>(shader_generated_path);
			AssetDatabase.SetLabels(this.result, new string[] { "Kawashirov-Generated-Shader-File", "Kawashirov", "Generated" });
			Shader.WarmupAllShaders();
			EditorUtility.FocusProjectWindow();
		}

		private void ConfigureGeneral(ref ShaderSetup shader)
		{
			shader.tags["IgnoreProjector"] = this.ignoreProjector ? "True" : "False";
			shader.tags["ForceNoShadowCasting"] = this.forceNoShadowCasting ? "True" : "False";
			shader.tags["DisableBatching"] = this.disableBatching ? "True" : "False";

			shader.SkipCommonStaticVariants();
			shader.Debug(this.debug);

			var instancing = this.instancing;
			if (this.complexity == ShaderComplexity.VHDGF)
				instancing = false;
			if (this.infinityWarDecimation)
				instancing = false;

			switch (this.complexity) {
				case ShaderComplexity.VHDGF:
					shader.tags["KawaFLT_Feature_Geometry"] = "True";
					shader.tags["KawaFLT_Feature_Tessellation"] = "True";
					shader.Include("KawaFLT_Struct_VHDGF.cginc");
					shader.Include("KawaFLT_PreFrag_VHDGF.cginc");
					break;
				case ShaderComplexity.VGF:
					shader.tags["KawaFLT_Feature_Geometry"] = "True";
					shader.tags["KawaFLT_Feature_Tessellation"] = "False";
					shader.Include("KawaFLT_Struct_VGF.cginc");
					shader.Include("KawaFLT_PreFrag_VGF.cginc");
					break;
				default:
					shader.tags["KawaFLT_Feature_Geometry"] = "False";
					shader.tags["KawaFLT_Feature_Tessellation"] = "False";
					shader.Include("KawaFLT_Struct_VF.cginc");
					shader.Include("KawaFLT_PreFrag_VF.cginc");
					break;
			}

			shader.forward.zWrite = this.zWrite;
			shader.forward.cullMode = this.cull;
			shader.forward.multi_compile_instancing = instancing;
			shader.forward.defines.Add("KAWAFLT_PASS_FORWARDBASE 1");
			shader.forward.includes.Add("KawaFLT_Frag_ForwardBase.cginc");
			shader.forward.vertex = "vert";
			shader.forward.hull = this.complexity == ShaderComplexity.VHDGF ? "hull" : null;
			shader.forward.domain = this.complexity == ShaderComplexity.VHDGF ? "domain" : null;
			shader.forward.geometry = this.complexity == ShaderComplexity.VHDGF || this.complexity == ShaderComplexity.VGF ? "geom" : null;
			shader.forward.fragment = "frag_forwardbase";

			shader.forward_add.zWrite = false;
			shader.forward_add.cullMode = this.cull;
			shader.forward_add.multi_compile_instancing = instancing;
			shader.forward_add.defines.Add("KAWAFLT_PASS_FORWARDADD 1");
			shader.forward_add.includes.Add("KawaFLT_Frag_ForwardAdd.cginc");
			shader.forward_add.vertex = "vert";
			shader.forward_add.hull = this.complexity == ShaderComplexity.VHDGF ? "hull" : null;
			shader.forward_add.domain = this.complexity == ShaderComplexity.VHDGF ? "domain" : null;
			shader.forward_add.geometry = this.complexity == ShaderComplexity.VHDGF || this.complexity == ShaderComplexity.VGF ? "geom" : null;
			shader.forward_add.fragment = "frag_forwardadd";

			shader.shadowcaster.cullMode = this.cull;
			shader.shadowcaster.multi_compile_instancing = instancing;
			shader.shadowcaster.defines.Add("KAWAFLT_PASS_SHADOWCASTER 1");
			shader.shadowcaster.includes.Add("KawaFLT_Frag_ShadowCaster.cginc");
			shader.shadowcaster.vertex = "vert";
			shader.shadowcaster.hull = this.complexity == ShaderComplexity.VHDGF ? "hull" : null;
			shader.shadowcaster.domain = this.complexity == ShaderComplexity.VHDGF ? "domain" : null;
			shader.shadowcaster.geometry = this.complexity == ShaderComplexity.VHDGF || this.complexity == ShaderComplexity.VGF ? "geom" : null;
			shader.shadowcaster.fragment = "frag_shadowcaster";
		}

		private void ConfigureBlending(ref ShaderSetup shader)
		{
			string q = null;
			switch (this.mode) {
				case BlendTemplate.Opaque:
					q = "Geometry";
					shader.tags["RenderType"] = "Opaque";
					shader.tags["KawaFLT_RenderType"] = "Opaque";
					shader.forward.srcBlend = BlendMode.One;
					shader.forward.srcBlend = BlendMode.Zero;
					shader.forward_add.srcBlend = BlendMode.One;
					shader.forward_add.srcBlend = BlendMode.One;
					break;
				case BlendTemplate.Cutout:
					q = "AlphaTest";
					shader.tags["RenderType"] = "TransparentCutout";
					shader.tags["KawaFLT_RenderType"] = "Cutout";
					shader.Define("_ALPHATEST_ON 1");
					shader.forward.srcBlend = BlendMode.One;
					shader.forward.srcBlend = BlendMode.Zero;
					shader.forward_add.srcBlend = BlendMode.One;
					shader.forward_add.srcBlend = BlendMode.One;
					break;
				case BlendTemplate.Fade:
					q = "Transparent";
					shader.tags["RenderType"] = "Transparent";
					shader.tags["KawaFLT_RenderType"] = "Fade";
					shader.Define("_ALPHABLEND_ON 1");
					shader.forward.srcBlend = BlendMode.SrcAlpha;
					shader.forward.srcBlend = BlendMode.OneMinusSrcAlpha;
					shader.forward_add.srcBlend = BlendMode.SrcAlpha;
					shader.forward_add.srcBlend = BlendMode.One;
					break;
			}
			shader.tags["Queue"] = string.Format("{0}{1:+#;-#;+0}", q, this.queueOffset);
			shader.shadowcaster.srcBlend = null;
			shader.shadowcaster.dstBlend = null;
		}

		private void ConfigureFeatureMainTex(ref ShaderSetup shader)
		{
			var mainTex = this.mainTex;
			if (this.mode == BlendTemplate.Cutout && mainTex == MainTexKeywords.Off)
				mainTex = MainTexKeywords.NoMask;

			shader.tags["KawaFLT_Feature_MainTex"] = Enum.GetName(typeof(MainTexKeywords), mainTex);

			switch (this.mainTex) {
				case MainTexKeywords.Off:
					shader.Define("MAINTEX_OFF 1");
					break;
				case MainTexKeywords.NoMask:
					shader.Define("MAINTEX_NOMASK 1");
					break;
				case MainTexKeywords.ColorMask:
					shader.Define("MAINTEX_COLORMASK 1");
					break;
			}

			if (this.mainTex == MainTexKeywords.ColorMask || this.mainTex == MainTexKeywords.NoMask) {
				shader.properties.Add(new Property2D() { name = "_MainTex" });
				if (this.mainTex == MainTexKeywords.ColorMask) {
					shader.properties.Add(new Property2D() { name = "_ColorMask", defualt = "black" });
				}
			}
		}

		private void ConfigureFeatureCutoff(ref ShaderSetup shader)
		{
			if (this.mode == BlendTemplate.Cutout || (this.mode == BlendTemplate.Fade && this.forceNoShadowCasting == false)) {
				shader.tags["KawaFLT_Feature_Cutout"] = Enum.GetName(typeof(CutoutMode), this.cutout);
				switch (this.cutout) {
					case CutoutMode.Classic:
						shader.Define("CUTOFF_CLASSIC 1");
						break;
					case CutoutMode.RangeRandom:
						shader.Define("CUTOFF_RANDOM 1");
						break;
					case CutoutMode.RangePattern:
						shader.Define("CUTOFF_PATTERN 1");
						break;
				}
				if (this.cutout == CutoutMode.Classic) {
					shader.properties.Add(new PropertyFloat() { name = "_Cutoff", defualt = 0.5f, range = new Vector2(0, 1) });
				}
				if (this.cutout == CutoutMode.RangeRandom || this.cutout == CutoutMode.RangePattern) {
					shader.properties.Add(new PropertyFloat() { name = "_CutoffMin", defualt = 0.4f, range = new Vector2(0, 1) });
					shader.properties.Add(new PropertyFloat() { name = "_CutoffMax", defualt = 0.6f, range = new Vector2(0, 1) });
				}
				if (this.cutout == CutoutMode.RangePattern) {
					shader.properties.Add(new Property2D() { name = "_CutoffPattern", defualt = "gray" });
				}
			}
		}

		private void ConfigureFeatureEmission(ref ShaderSetup shader)
		{
			shader.tags["KawaFLT_Feature_Emission"] = Enum.GetName(typeof(EmissionMode), this.emission);
			switch (this.emission) {
				case EmissionMode.Off:
					shader.forward.defines.Add("EMISSION_OFF 1");
					break;
				case EmissionMode.AlbedoNoMask:
					shader.forward.defines.Add("EMISSION_ALBEDO_NOMASK 1");
					break;
				case EmissionMode.AlbedoMask:
					shader.forward.defines.Add("EMISSION_ALBEDO_MASK 1");
					break;
				case EmissionMode.Custom:
					shader.forward.defines.Add("EMISSION_CUSTOM 1");
					break;
			}
			if (this.emission == EmissionMode.AlbedoMask || this.emission == EmissionMode.Custom) {
				shader.properties.Add(new Property2D() { name = "_EmissionMap", defualt = "white" });
			}
			if (this.emission != EmissionMode.Off) {
				shader.properties.Add(new PropertyColor() { name = "_EmissionColor", defualt = Color.black });
			}
		}

		private void ConfigureFeatureNormalMap(ref ShaderSetup shader) {
			shader.tags["KawaFLT_Feature_NormalMap"] = this.bumpMap ? "True" : "False";
			if (this.bumpMap) {
				shader.forward.defines.Add("_NORMALMAP");
				shader.forward_add.defines.Add("_NORMALMAP");
				shader.properties.Add(new Property2D() { name = "_BumpMap", defualt = "bump", isNormal = true });
				shader.properties.Add(new PropertyFloat() { name = "_BumpScale", defualt = 1.0f });
			}
		}

		private void ConfigureFeatureShading(ref ShaderSetup shader) {
			shader.tags["KawaFLT_Feature_Shading"] = Enum.GetName(typeof(ShadingMode), this.shading);
			switch (this.shading) {
				case ShadingMode.CubedParadoxFLT:
					shader.forward.defines.Add("SHADE_CUBEDPARADOXFLT 1");
					shader.forward_add.defines.Add("SHADE_CUBEDPARADOXFLT 1");
					this.ConfigureFeatureShadingCubedParadox(ref shader);
					break;
				case ShadingMode.KawashirovFLTSingle:
					shader.forward.defines.Add("SHADE_KAWAFLT_SINGLE 1");
					shader.forward_add.defines.Add("SHADE_KAWAFLT_SINGLE 1");
					this.ConfigureFeatureShadingKawashirovFLTSingle(ref shader);
					break;
				case ShadingMode.KawashirovFLTRamp:
					shader.forward.defines.Add("SHADE_KAWAFLT_RAMP 1");
					shader.forward_add.defines.Add("SHADE_KAWAFLT_RAMP 1");
					this.ConfigureFeatureShadingKawashirovFLTRamp(ref shader);
					break;
			}
		}

		private void ConfigureFeatureShadingCubedParadox(ref ShaderSetup shader) {
			shader.properties.Add(new PropertyFloat() { name = "_Sh_Cbdprdx_Shadow", defualt = 0.4f, range = new Vector2(0, 1) });
		}

		private void ConfigureFeatureShadingKawashirovFLTSingle(ref ShaderSetup shader)
		{
			shader.properties.Add(new PropertyFloat() { name = "_Sh_Kwshrv_ShdBlnd", defualt = 0.7f, range = new Vector2(0, 1), power = 2 });
			shader.properties.Add(new PropertyFloat() { name = "_Sh_KwshrvSngl_TngntLo", defualt = 0.7f, range = new Vector2(0, 1), power = 1.5f });
			shader.properties.Add(new PropertyFloat() { name = "_Sh_KwshrvSngl_TngntHi", defualt = 0.8f, range = new Vector2(0, 1), power = 1.5f });
			shader.properties.Add(new PropertyFloat() { name = "_Sh_KwshrvSngl_ShdLo", defualt = 0.4f, range = new Vector2(0, 1) });
			shader.properties.Add(new PropertyFloat() { name = "_Sh_KwshrvSngl_ShdHi", defualt = 0.9f, range = new Vector2(0, 1) });
		}

		private void ConfigureFeatureShadingKawashirovFLTRamp(ref ShaderSetup shader)
		{
			shader.properties.Add(new PropertyFloat() { name = "_Sh_Kwshrv_ShdBlnd", defualt = 0.7f, range = new Vector2(0, 1), power = 2 });
			shader.properties.Add(new Property2D() { name = "_Sh_KwshrvRmp_Tex", defualt = "gray" });
			shader.properties.Add(new PropertyColor() { name = "_Sh_KwshrvRmp_NdrctClr", defualt = Color.white });
			shader.properties.Add(new PropertyFloat() { name = "_Sh_KwshrvSngl_TngntLo", defualt = 0.7f, range = new Vector2(0, 1), power = 1.5f });
		}

		private void ConfigureFeatureDistanceFade(ref ShaderSetup shader)
		{
			shader.tags["KawaFLT_Feature_DistanceFade"] = Enum.GetName(typeof(DistanceFadeMode), this.distanceFade);
			switch (this.distanceFade) {
				case DistanceFadeMode.None:
					shader.Define("DSTFD_OFF 1");
					return;
				case DistanceFadeMode.Range:
					shader.Define("DSTFD_RANGE 1");
					break;
				case DistanceFadeMode.Infinity:
					shader.Define("DSTFD_INFINITY 1");
					break;
			}
			shader.tags["KawaFLT_Feature_DistanceFadeRandom"] = Enum.GetName(typeof(DistanceFadeRandom), this.distanceFadeRandom);
			switch (this.distanceFadeRandom) {
				case DistanceFadeRandom.PerPixel:
					shader.Define("DSTFD_RANDOM_PIXEL 1");
					break;
				case DistanceFadeRandom.ScreenPattern:
					shader.Define("DSTFD_RANDOM_PATTERN 1");
					break;
			}
			shader.properties.Add(new PropertyVector() { name = "_DstFd_Axis", defualt = Vector4.one });
			shader.properties.Add(new PropertyFloat() { name = "_DstFd_Near", defualt = 1.0f });
			shader.properties.Add(new PropertyFloat() { name = "_DstFd_Far", defualt = 2.0f });
			shader.properties.Add(new PropertyFloat() { name = "_DstFd_AdjustPower", defualt = 1.0f, range = new Vector2(0.1f, 10), power = 10 });
			shader.properties.Add(new PropertyFloat() { name = "_DstFd_AdjustScale", defualt = 1.0f, range = new Vector2(0.1f, 10) });
			if (this.distanceFadeRandom == DistanceFadeRandom.ScreenPattern) {
				shader.properties.Add(new Property2D() { name = "_DstFd_Pattern", defualt = "white" });
			}
		}

		private void ConfigureFeatureFPS(ref ShaderSetup shader) {
			shader.tags["KawaFLT_Feature_FPS"] = Enum.GetName(typeof(FPSMode), this.FPS);
			switch (this.FPS) {
				case FPSMode.None:
					return;
				case FPSMode.Color:
					shader.Define("FPS_COLOR 1");
					break;
				case FPSMode.Texture:
					shader.Define("FPS_TEX 1");
					break;
				case FPSMode.Mesh:
					shader.Define("FPS_MESH 1");
					break;
			}
			shader.properties.Add(new PropertyColor() { name = "_FPS_TLo", defualt = new Color(1, 0.5f, 0.5f, 1) });
			shader.properties.Add(new PropertyColor() { name = "_FPS_THi", defualt = new Color(0.5f, 1, 0.5f, 1) });
		}

		private void ConfigureFeatureInfinityWarDecimation(ref ShaderSetup shader)
		{
			shader.tags["KawaFLT_Feature_InfinityWarDecimation"] = this.infinityWarDecimation ? "True" : "False";
			shader.properties.Add(new PropertyVector() { name = "_Dsntgrt_Plane", defualt = Vector4.zero });
			shader.properties.Add(new PropertyFloat() { name = "_Dsntgrt_TriSpreadAccel", defualt = 2, range = new Vector2(0, 5) });
			shader.properties.Add(new PropertyFloat() { name = "_Dsntgrt_TriSpreadFactor", defualt = 0.1f, range = new Vector2(0, 1) });
			shader.properties.Add(new PropertyFloat() { name = "_Dsntgrt_TriDecayNear", defualt = 0, range = new Vector2(0, 10) });
			shader.properties.Add(new PropertyFloat() { name = "_Dsntgrt_TriDecayFar", defualt = 0.5f, range = new Vector2(0, 10) });
			shader.properties.Add(new PropertyFloat() { name = "_Dsntgrt_TriPowerAdjust", defualt = 1, range = new Vector2(0.5f, 2) });
			shader.properties.Add(new PropertyColor() { name = "_Dsntgrt_Tint", defualt = new Color(0.2f, 0.2f, 0.2f, 0.1f) });
			if (this.complexity == ShaderComplexity.VHDGF) {
				shader.properties.Add(new PropertyFloat() { name = "_Dsntgrt_Tsltn", defualt = 1, range = new Vector2(0, 10), power = 2 });
			}
		}

		private void ConfigureFeaturePolyColorWave(ref ShaderSetup shader)
		{
			shader.tags["KawaFLT_Feature_PCW"] = Enum.GetName(typeof(PolyColorWaveMode), this.polyColorWave);

		}

	}
}